# fp_lab2 - Словарь на основе префиксного дерева

Лабораторная работа по функциональному программированию, реализующая структуру данных **словарь на основе префиксного дерева (trie)** на языке Haskell.

## Обзор

Этот проект реализует неизменяемый словарь на основе префиксного дерева, который отображает ключи типа `String` на полиморфные значения. Структура является **моноидом** и предоставляет эффективные операции для манипулирования словарём.

## Возможности

### Основные операции

- **Вставка и удаление**: Добавление или удаление пар ключ-значение
  - [`insertDict`](src/Structure.hs:23) - Вставка пары ключ-значение
  - [`deleteDict`](src/Structure.hs:29) - Удаление ключа из словаря
  
- **Поиск и проверка наличия**: Запросы к словарю
  - [`lookupDict`](src/Structure.hs:35) - Получение значения по ключу
  - [`memberDict`](src/Structure.hs:39) - Проверка существования ключа

- **Фильтрация**: Фильтрация записей по предикату
  - [`filterDict`](src/Structure.hs:42) - Фильтрация по предикату ключ-значение

- **Отображение**: Преобразование значений
  - [`mapDict`](src/Structure.hs:54) - Применение функции ко всем значениям

- **Свёртки**: Агрегация записей словаря
  - [`foldlDict`](src/Structure.hs:45) - Левая свёртка по записям
  - [`foldrDict`](src/Structure.hs:51) - Правая свёртка по записям

- **Слияние**: Объединение словарей
  - [`mergeDict`](src/Structure.hs:57) - Слияние двух словарей (правый имеет приоритет)

### Свойства моноида

[`PrefixTreeDict`](src/Structure.hs:8) реализует класс типов `Monoid`:
- **Нейтральный элемент**: `mempty` - пустой словарь
- **Ассоциативность**: `(a <> b) <> c == a <> (b <> c)`
- **Левая нейтральность**: `mempty <> a == a`
- **Правая нейтральность**: `a <> mempty == a`

## Структура

Префиксное дерево реализовано с использованием:
- [`Node`](src/Structure.hs:9) - Содержит опциональное значение и дочерние узлы
- [`Children`](src/Structure.hs:14) - Отсортированный список пар символ-узел для эффективного поиска по префиксу

## Тестирование

Проект включает комплексное тестирование:

### Unit-тесты
- Операции вставки и поиска
- Операции удаления с сохранением префиксов
- Функциональность фильтрации
- Агрегация через свёртки
- Преобразования через map
- Проверка поведения префиксов

### Property-based тесты (QuickCheck)
- Законы моноида (левая нейтральность, правая нейтральность, ассоциативность)
- Согласованность вставки и поиска
- Согласованность удаления и поиска
- Эквивалентность фильтрации со списочными операциями
- Эквивалентность отображения со списочными операциями
- Согласованность свёрток

## Сборка и запуск

```bash
# Сборка проекта
cabal build

# Запуск тестов
cabal test

# Запуск исполняемого файла
cabal run fp-lab2
```

## Детали реализации

- **Неизменяемость**: Все операции возвращают новые экземпляры словаря
- **Полиморфизм**: Значения могут быть любого типа
- **Эффективность**: 
  - Поиск: O(k), где k - длина ключа
  - Вставка: O(k), где k - длина ключа
  - Удаление: O(k), где k - длина ключа
  - Дочерние узлы хранятся отсортированными для согласованного порядка

## Дизайн API

API спроектирован так, чтобы быть:
- **Непротекающим**: Внутреннее представление скрыто
- **Идиоматичным**: Следует соглашениям Haskell
- **Типобезопасным**: Использует систему типов Haskell
- **Эффективным**: Оптимизирован для общих операций

## Файлы

- [`src/Structure.hs`](src/Structure.hs) - Основная реализация
- [`test/Main.hs`](test/Main.hs) - Unit и property-based тесты
- [`app/Main.hs`](app/Main.hs) - Точка входа исполняемого файла
- [`Setup.hs`](Setup.hs) - Скрипт настройки Cabal
- [`fp_lab2.cabal`](fp_lab2.cabal) - Конфигурация проекта
